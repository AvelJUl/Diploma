import numpy as np


class Config(object):
    """
    Базовый класс конфигурации. Для пользовательчких конфигураций необходжимо
    создать класс, который наследуется от этого и переопределяет необходимые свойства.
    """

    # Название конфигурации
    NAME = None

    # Количество графических процессоров для использования.
    # При использовании только CPU параметр должен быть установлено в 1.
    GPU_COUNT = 1

    # Количество изображений для обучения на каждом графическом процессоре.
    IMAGES_PER_GPU = 1

    # Количество шагов за одну эпоху во время обчения.
    STEPS_PER_EPOCH = 1000

    # Количество шагов проверки, выполняемых в конце каждой эпохи обучения.
    # Большее число увеличивает точность, но замедляет обучение.
    VALIDATION_STEPS = 50

    # Архитектура магистральной нейронной сверточной сети сети.
    BACKBONE = "resnet101"

    # Величины шага свертки каждого слоя FPN Pyramid.
    BACKBONE_STRIDES = [4, 8, 16, 32, 64]

    # Размер полносвязных слоев в графе классификации.
    FPN_CLASSIF_FC_LAYERS_SIZE = 1024

    # Размер нисходящих слоев, используемых для построения пирамиды признаков
    TOP_DOWN_PYRAMID_SIZE = 256

    # Количество классификационных классов (включая фоновые).
    # Необходимо переопределить в наследуемом классе.
    NUM_CLASSES = 1

    # Длина стороны квадратного якоря в пикселях
    RPN_ANCHOR_SCALES = (32, 64, 128, 256, 512)

    # Соотношение якорей в каждой ячейке (ширина / высота).
    # Значение 1 представляет квадратный якорь, а 0,5 - широкий якорь.
    RPN_ANCHOR_RATIOS = [0.5, 1, 2]

    # Значение шага якоря.
    # Если 1, то якоря создаются для каждой ячейки в карте базовых признаков.
    # Если 2, то якоря создаются для каждой другой ячейки и т.д.
    RPN_ANCHOR_STRIDE = 1

    # Не максимальные порог подавления для фильтрации предложений RPN.
    RPN_NMS_THRESHOLD = 0.75

    # Количество якорей на изображение, использоуемых для обучения RPN.
    RPN_TRAIN_ANCHORS_PER_IMAGE = 256

    # ROI сохраняются после tf.nn.top_k и до не максимального подавления
    PRE_NMS_LIMIT = 6000

    # ROI сохраняются после не максимального подавления (обучение и вывод)
    POST_NMS_ROIS_TRAINING = 2000
    POST_NMS_ROIS_INFERENCE = 1000

    # Если установлено, изменяет размер экземпляра маски до меньшего,
    # чтобы снизить нагрузку на память. Рекомендуется при использовании
    # изображений с высоким разрешением.
    USE_MINI_MASK = True
    # (высота, ширина) мини-маски
    MINI_MASK_SHAPE = (56, 56)

    # Изменение размера входного изображения
    # В режиме "square" изображения масштабируются таким образом, чтобы малая
    # сторона была = IMAGE_MIN_DIM, но при этом необходимо гарантировать, что
    # при масштабировании не будет длинной стороны > IMAGE_MAX_DIM. Затем
    # изображение дополняется нулями, чтобы сделать его квадратным, чтобы можно
    # было поместить несколько изображений в один пакет.
    IMAGE_RESIZE_MODE = 'square'
    IMAGE_MIN_DIM = 800
    IMAGE_MAX_DIM = 1024

    # Минимальный коэффициент масштабирования. Проверяется после MIN_IMAGE_DIM
    # и может увеличивать масштабирование. Например, если установлено значение 2,
    # изображения масштабируются до удвоенной ширины и высоты или более, даже
    # если MIN_IMAGE_DIM этого не требует.
    # Однако в «square» режиме это может быть отменено IMAGE_MAX_DIM.
    IMAGE_MIN_SCALE = 0
    # Количество цветовых каналов на изображение. RGB = 3, grayscale = 1, RGB-D = 4
    # Изменение этого требует других изменений в коде. Смотрите вики для более
    # подробной информации: https://github.com/matterport/Mask_RCNN/wiki
    IMAGE_CHANNEL_COUNT = 3

    # (RGB)
    MEAN_PIXEL = np.array([123.7, 116.8, 103.9])

    # Число областей интереса на изображение для подачи на классификатор / маски.
    # В документе Mask RCNN используется 512, но часто RPN не генерирует достаточно
    # положительных предложений, чтобы заполнить это и сохранить соотношение
    # положительное:отрицательное 1:3. Вы можете увеличить количество предложений,
    # настроив порог RPN NMS.
    TRAIN_ROIS_PER_IMAGE = 200

    # Процент положительных ROI, использованных для обучения голов классификатора /
    # маски.
    ROI_POSITIVE_RATIO = 0.33

    # Пул ROI
    POOL_SIZE = 7
    MASK_POOL_SIZE = 14

    # Разрешение выходной маски
    # Чтобы изменить это, вам также нужно изменить ветвь маски нейронной сети.
    MASK_SHAPE = [28, 28]

    # Максимальное количество экземпляров основы истины для одного изображения.
    MAX_GT_INSTANCES = 100

    # Стандартное отклонение уточнения ограничивающей рамки для RPN и окончательных
    # обнаружений.
    RPN_BBOX_STD_DEV = np.array([0.1, 0.1, 0.2, 0.2])
    BBOX_STD_DEV = np.array([0.1, 0.1, 0.2, 0.2])

    # Максимальное количество финальных обнаружений.
    DETECTION_MAX_INSTANCES = 100

    # Минимальное значение вероятности для принятия обнаруженного экземпляра.
    # ROIs ниже этого порога пропускаются.
    DETECTION_MIN_CONFIDENCE = 0.7

    # Не максимальный порог подавления для обнаружения.
    DETECTION_NMS_THRESHOLD = 0.3

    # Скорость обучения и импульс.
    # В документе Mask RCNN используется lr = 0,02, но в TensorFlow это приводит
    # к взрыву весов. Вероятно, из-за различий в реализации оптимизатора.
    LEARNING_RATE = 0.001
    LEARNING_MOMENTUM = 0.9

    # Регуляризация снижения веса.
    WEIGHT_DECAY = 0.0001

    # Потеря веса для более точной оптимизации.
    # Может использоваться для настройки обучения R-CNN.
    LOSS_WEIGHTS = {
        "rpn_class_loss": 1.,
        "rpn_bbox_loss": 1.,
        "mrcnn_class_loss": 1.,
        "mrcnn_bbox_loss": 1.,
        "mrcnn_mask_loss": 1.
    }

    # Использовать RPN ROIs или внешне сгенерированные ROIs для обучения
    # Используйте True для большинства ситуаций. Установите значение False,
    # если вы хотите обучать главные ветви по ROI, генерируемым кодом, а не
    # по ROI из RPN. Например, для отладки головы классификатора без
    # необходимости обучения RPN.
    USE_RPN_ROIS = True

    # Обучить или заморозить нормальзующие пакеты.
    #     None -- обучение.
    #     False -- заморозка слоя. Хорошо при использовании небольшого размера
    #     пакета.
    #     True -- (не использовать). Установить слой в режиме обучения даже
    #     при прогнозировании.
    # По умолчанию используется значение False, поскольку размер партии часто невелик.
    TRAIN_BN = False

    # Градиентная норма отсечения.
    GRADIENT_CLIP_NORM = 5.0

    def __init__(self):
        """Установка значений вычисляемых атрибутов."""
        # Эффективный размер пакета
        self.BATCH_SIZE = self.IMAGES_PER_GPU * self.GPU_COUNT

        # Размер входного изображения
        self.IMAGE_SHAPE = np.array([self.IMAGE_MAX_DIM, self.IMAGE_MAX_DIM,
                                     self.IMAGE_CHANNEL_COUNT])

        # Длина метаданных изображения.
        # Смотрите compose_image_meta () для подробностей.
        self.IMAGE_META_SIZE = 1 + 3 + 3 + 4 + 1 + self.NUM_CLASSES

    def display(self):
        """Отображение значений конфигурации."""
        print("\nConfigurations:")
        for a in dir(self):
            if not a.startswith("__") and not callable(getattr(self, a)):
                print("{:30} {}".format(a, getattr(self, a)))
        print("\n")
